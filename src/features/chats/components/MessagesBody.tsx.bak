import { Box, Grid, useMediaQuery } from "@mui/material"
import React, { useCallback, useEffect, useRef, useState } from "react"
import { useTheme } from "@mui/material/styles"
import { ExtendedTheme } from "../../../hooks/styles/Theme"
import { AccessTimeRounded } from "@mui/icons-material"
import { useCurrentChat } from "../hooks/CurrentChat"
import {
  useSendChatMessageMutation,
  useGetChatByIDQuery,
  chatsApi,
} from "../api/chatsApi"
import { useParams } from "react-router-dom"
import { io } from "socket.io-client"
import { WS_URL } from "../../../util/constants"
import { useDispatch } from "react-redux"
import type { AppDispatch } from "../../../store/store"
import moment from "moment"
import { useAlertHook } from "../../../hooks/alert/AlertHook"
import { MobileFAB } from "../../../components/mobile/MobileFAB"
import {
  MessageHeader,
  DateTimePickerBottomSheet,
  MessagesArea,
  MessageSendArea,
} from "../messages"

function MessageHeader(props: {
  dateTime: moment.Moment
  setDateTime: (dateTime: moment.Moment) => void
}) {
  const profile = useGetUserProfileQuery()
  const theme = useTheme<ExtendedTheme>()
  const isMobile = useMediaQuery(theme.breakpoints.down("md"))
  const [messageSidebarOpen, setMessageSidebar] = useMessagingSidebar()
  const navigate = useNavigate()
  const location = useLocation()

  const [chat] = useCurrentChat()

  const { dateTime, setDateTime } = props
  const { t } = useTranslation()

  // Check if we're viewing from orders or offers page
  const isViewingFromOrderOrOffer =
    location.pathname.includes("/order/") ||
    location.pathname.includes("/offer/")

  return (
    <Box
      sx={{
        width: "100%",
        padding: { xs: 1.5, sm: 2 },
        boxSizing: "border-box",
        borderWidth: 0,
        borderBottom: `solid 1px ${theme.palette.outline.main}`,
        bgcolor: theme.palette.background.paper,
        display: "flex",
        flexDirection: { xs: "column", sm: "row" },
        justifyContent: "space-between",
        alignItems: { xs: "flex-start", sm: "center" },
        gap: { xs: 1, sm: 0 },
        minHeight: { xs: "auto", sm: 64 },
      }}
    >
              flexShrink: 0,
            }}
            src={author?.avatar}
          />
        </Link>
        <Box
          sx={{
            flexGrow: 1,
            maxWidth: { xs: "85%", sm: "90%" },
            minWidth: 0, // Allow text to shrink
          }}
        >
          <MsgPaper other author={author}>
            <Typography
              color={theme.palette.text.secondary}
              align={"left"}
              width={"100%"}
              sx={{
                fontWeight: 400,
                overflowWrap: "break-word",
                fontSize: ".9em",
              }}
            >
              {convertedContent}
            </Typography>
          </MsgPaper>
          <Typography
            align={"left"}
            color={"text.primary"}
            variant={"subtitle2"}
            sx={{
              marginTop: 0.5,
              marginLeft: 2,
              fontSize: "0.75em",
              lineHeight: 1.66,
            }}
          >
            {getRelativeTime(new Date(message.timestamp))}
          </Typography>
        </Box>
      </Stack>
    )
  }
}

function MessagesArea(props: {
  messages: Message[]
  messageBoxRef: RefObject<HTMLDivElement | null>
  maxHeight?: number
  inputAreaHeight?: number
}) {
  const theme = useTheme<ExtendedTheme>()
  const isMobile = useMediaQuery(theme.breakpoints.down("md"))
  const { messageBoxRef, inputAreaHeight } = props
  const [chat] = useCurrentChat()

  useEffect(() => {
    const currentRef = messageBoxRef.current
    if (currentRef) {
      currentRef.scrollTop = currentRef.scrollHeight
    }
  }, [messageBoxRef, chat, props.messages])

  const { messages } = props
  return (
    <React.Fragment>
      <Box
        ref={messageBoxRef}
        sx={{
          flexGrow: 1,
          width: "100%",
          padding: { xs: 1.5, sm: 2 },
          paddingBottom: { xs: 2, sm: 2 },
          borderColor: theme.palette.outline.main,
          boxSizing: "border-box",
          borderWidth: 0,
          borderStyle: "solid",
          overflow: "auto",
          maxHeight: props.maxHeight,
          WebkitOverflowScrolling: "touch", // Smooth scrolling on iOS
          minHeight: 0,
          flex: 1,
          // On mobile, add bottom padding to account for fixed input area
          marginBottom:
            isMobile && inputAreaHeight ? `${inputAreaHeight}px` : 0,
          position: "relative",
          zIndex: 1, // Lower than FAB
        }}
      >
        <Stack spacing={theme.layoutSpacing.compact}>
          {messages.map((message: Message) => (
            <MessageEntry2 message={message} key={message.timestamp} />
          ))}
        </Stack>
        <div ref={props.messageBoxRef} />
      </Box>
    </React.Fragment>
  )
}

function MessageSendArea(props: { onSend: (content: string) => void }) {
  const theme = useTheme<ExtendedTheme>()
  const isMobile = useMediaQuery(theme.breakpoints.down("md"))
  const [textEntry, setTextEntry] = useState("")
  const { t } = useTranslation()
  const inputRef = useRef<HTMLDivElement>(null)
  const [isKeyboardOpen, setIsKeyboardOpen] = useState(false)

  // Track keyboard visibility
  useEffect(() => {
    if (!isMobile) return

    const handleResize = () => {
      // On mobile, if viewport height is significantly reduced, keyboard is likely open
      const viewportHeight = window.visualViewport?.height || window.innerHeight
      const screenHeight = window.screen.height
      // If viewport is less than 75% of screen height, assume keyboard is open
      setIsKeyboardOpen(viewportHeight < screenHeight * 0.75)
    }

    // Use visualViewport API if available (better for mobile)
    if (window.visualViewport) {
      window.visualViewport.addEventListener("resize", handleResize)
      return () => {
        window.visualViewport?.removeEventListener("resize", handleResize)
      }
    } else {
      window.addEventListener("resize", handleResize)
      return () => {
        window.removeEventListener("resize", handleResize)
      }
    }
  }, [isMobile])

  const handleSend = () => {
    if (textEntry.trim()) {
      props.onSend(textEntry)
      setTextEntry("")
    }
  }

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault()
      handleSend()
    }
    // Shift+Enter allows newline (default behavior)
  }

  return (
    <Box
      ref={inputRef}
      sx={{
        width: "100%",
        padding: { xs: 1.5, sm: 1 },
        borderTopColor: theme.palette.outline.main,
        boxSizing: "border-box",
        borderWidth: 0,
        borderTop: `solid 1px ${theme.palette.outline.main}`,
        display: "flex",
        flexDirection: "row",
        gap: { xs: 1, sm: 0 },
        bgcolor: theme.palette.background.paper,
        alignItems: { xs: "flex-end", sm: "center" },
        position: isMobile ? "fixed" : "relative",
        bottom: isMobile
          ? isKeyboardOpen
            ? 0
            : "calc(64px + env(safe-area-inset-bottom))"
          : "auto",
        left: isMobile ? 0 : "auto",
        right: isMobile ? 0 : "auto",
        zIndex: isMobile ? theme.zIndex.drawer + 2 : "auto", // Above bottom nav but below modals
        // On mobile, add safe area padding for iOS keyboard
        paddingBottom: isMobile
          ? `calc(1.5rem + env(safe-area-inset-bottom))`
          : 1,
      }}
    >
      <TextField
        fullWidth
        multiline
        maxRows={isMobile ? 3 : 4}
        variant={"outlined"}
        size={isMobile ? "small" : "medium"}
        sx={{
          marginRight: { xs: 0, sm: 2 },
          marginBottom: { xs: 0, sm: 0 },
        }}
        value={textEntry}
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          setTextEntry(event.target.value)
        }}
        onKeyPress={handleKeyPress}
        placeholder={t("MessagesBody.typeMessage") || "Type a message..."}
      />
      {isMobile ? (
        <IconButton
          color="primary"
          onClick={handleSend}
          sx={{
            flexShrink: 0,
            alignSelf: "flex-end",
            marginBottom: 0.5, // Align with text field baseline
          }}
        >
          <SendIcon />
        </IconButton>
      ) : (
        <Button
          variant={"contained"}
          color={"primary"}
          sx={{
            maxHeight: 60,
            whiteSpace: "nowrap",
          }}
          onClick={handleSend}
          size="large"
        >
          {t("MessagesBody.send")}
        </Button>
      )}
    </Box>
  )
}

export const socket = io(WS_URL, {
  withCredentials: true,
  path: "/ws",
  reconnectionDelay: 4000,
  autoConnect: false,
  secure: true,
  transports: ["websocket", "polling", "xhr-polling"],
})

/**
 * The main messages body used across Orders and Offers
 */
export function MessagesBody(props: {
  maxHeight?: number
  forceDesktop?: boolean
}) {
  const theme = useTheme<ExtendedTheme>()
  const dispatch = useDispatch<AppDispatch>()
  const isMobileQuery = useMediaQuery(theme.breakpoints.down("md"))
  const isMobile = props.forceDesktop ? false : isMobileQuery
  const [currentChat, setCurrentChat] = useCurrentChat()
  const messageBoxRef = useRef<HTMLDivElement>(null)
  const [sendChatMessage] = useSendChatMessageMutation()
  const { isSuccess } = useGetUserProfileQuery()
  const { data: profile } = useGetUserProfileQuery()

  useEffect(() => {
    if (isSuccess && !socket.connected) {
      socket.connect()
    }

    if (!isSuccess || socket.connected) {
      socket.disconnect()
    }
  }, [isSuccess])

  // Listen for server messages from socket
  useEffect(() => {
    function onServerMessage(message: Message): void {
      setCurrentChat((chat) => {
        if (chat && message.chat_id === chat.chat_id) {
          // Find matching message by content + author (replace optimistic with server message)
          const messageIndex = chat.messages.findIndex(
            (msg) =>
              msg.content === message.content && msg.author === message.author,
          )

          if (messageIndex >= 0) {
            // Replace optimistic message with server message
            const updatedMessages = [...chat.messages]
            updatedMessages[messageIndex] = message
            return {
              ...chat,
              messages: updatedMessages.sort(
                (a: Message, b: Message) => a.timestamp - b.timestamp,
              ),
            }
          } else {
            // New message, add it
            return {
              ...chat,
              messages: [...chat.messages, message].sort(
                (a: Message, b: Message) => a.timestamp - b.timestamp,
              ),
            }
          }
        }
        return chat
      })

      // Also update RTK Query cache so it stays in sync
      dispatch(
        chatsApi.util.updateQueryData(
          "getChatByID",
          message.chat_id,
          (draft) => {
            // Find matching message by content + author (replace optimistic with server message)
            const messageIndex = draft.messages.findIndex(
              (msg) =>
                msg.content === message.content &&
                msg.author === message.author,
            )

            if (messageIndex >= 0) {
              // Replace optimistic message with server message
              draft.messages[messageIndex] = message
            } else {
              // New message, add it
              draft.messages.push(message)
            }
            draft.messages.sort(
              (a: Message, b: Message) => a.timestamp - b.timestamp,
            )
          },
        ),
      )
    }
    socket.on("serverMessage", onServerMessage)
    return () => {
      socket.off("serverMessage", onServerMessage)
    }
  }, [setCurrentChat, dispatch])

  useEffect(() => {
    if (currentChat) {
      socket.emit("clientJoinRoom", { chat_id: currentChat.chat_id })
    }
    return () => {
      if (currentChat) {
        socket.emit("clientLeaveRoom", { chat_id: currentChat.chat_id })
      }
    }
  }, [currentChat?.chat_id])

  // Subscribe to RTK Query cache updates to sync with currentChat state
  const { chat_id } = useParams<{ chat_id: string }>()
  const { data: chatFromCache } = useGetChatByIDQuery(chat_id!, {
    skip: !chat_id,
  })

  // Sync cache with local state, but merge messages to preserve optimistic updates and socket messages
  useEffect(() => {
    if (
      chatFromCache &&
      currentChat &&
      chatFromCache.chat_id === currentChat.chat_id
    ) {
      const sortedCacheMessages = [...chatFromCache.messages].sort(
        (a: Message, b: Message) => a.timestamp - b.timestamp,
      )

      // Merge messages: combine cache messages with any local messages that aren't in cache
      // This preserves optimistic updates and socket messages that haven't been synced to cache yet
      // Use composite key (content + author) to uniquely identify messages since timestamp is server-side
      const getMessageKey = (msg: Message) =>
        `${msg.content}-${msg.author || "system"}`

      const localMessageMap = new Map<string, Message>()
      currentChat.messages.forEach((msg) => {
        const key = getMessageKey(msg)
        localMessageMap.set(key, msg)
      })

      const cacheMessageMap = new Map<string, Message>()
      sortedCacheMessages.forEach((msg) => {
        const key = getMessageKey(msg)
        cacheMessageMap.set(key, msg)
      })

      // Merge: start with cache messages, add any local messages not in cache
      const mergedMessages = [...sortedCacheMessages]
      localMessageMap.forEach((msg) => {
        const key = getMessageKey(msg)
        if (!cacheMessageMap.has(key)) {
          mergedMessages.push(msg)
        }
      })

      // Sort merged messages
      const sortedMerged = mergedMessages.sort(
        (a: Message, b: Message) => a.timestamp - b.timestamp,
      )

      // Only update if messages actually differ
      const currentSorted = [...currentChat.messages].sort(
        (a: Message, b: Message) => a.timestamp - b.timestamp,
      )

      // Compare using content + author since timestamp may differ between optimistic and server
      const mergedKeys = new Set(sortedMerged.map(getMessageKey))
      const currentKeys = new Set(currentSorted.map(getMessageKey))

      if (
        mergedKeys.size !== currentKeys.size ||
        !Array.from(mergedKeys).every((key) => currentKeys.has(key))
      ) {
        setCurrentChat({
          ...chatFromCache,
          messages: sortedMerged,
        })
      }
    }
  }, [chatFromCache, currentChat, setCurrentChat])

  const issueAlert = useAlertHook()

  const onSend = useCallback(
    (content: string) => {
      if (content && currentChat) {
        // RTK Query handles optimistic updates, so we just send the message
        // The cache update will sync to currentChat via the useEffect
        sendChatMessage({ chat_id: currentChat.chat_id, content })
          .unwrap()
          .catch((error) => {
            issueAlert(error)
          })
      }
    },
    [currentChat, sendChatMessage, issueAlert],
  )

  const { t } = useTranslation()
  const [dateTime, setDateTime] = useState(moment())
  const [dateTimeSheetOpen, setDateTimeSheetOpen] = useState(false)
  const inputAreaRef = useRef<HTMLDivElement>(null)
  const [inputAreaHeight, setInputAreaHeight] = useState(0)

  // Measure input area height for proper spacing
  useEffect(() => {
    if (isMobile && inputAreaRef.current) {
      const updateHeight = () => {
        setInputAreaHeight(inputAreaRef.current?.offsetHeight || 0)
      }
      updateHeight()
      const resizeObserver = new ResizeObserver(updateHeight)
      resizeObserver.observe(inputAreaRef.current)
      return () => resizeObserver.disconnect()
    }
  }, [isMobile])

  return (
    <>
      {currentChat && (
        <Box
          sx={{
            display: "flex",
            flexDirection: "column",
            height: "100%",
            minHeight: 0,
            overflow: "hidden",
            position: "relative",
            isolation: "isolate", // Create new stacking context for FAB
          }}
        >
          <MessageHeader dateTime={dateTime} setDateTime={setDateTime} />
          <Box
            sx={{
              flex: 1,
              minHeight: 0,
              display: "flex",
              flexDirection: "column",
              position: "relative",
            }}
          >
            <MessagesArea
              messages={currentChat.messages}
              messageBoxRef={messageBoxRef}
              maxHeight={props.maxHeight}
              inputAreaHeight={inputAreaHeight}
            />

            {/* Mobile FAB for date/time picker - positioned above input area */}
            {isMobile && (
              <Box
                sx={{
                  position: "absolute",
                  bottom: inputAreaHeight
                    ? `${inputAreaHeight + 64}px`
                    : "144px", // Position 64px above input
                  right: 16,
                  zIndex: theme.zIndex.speedDial, // Use theme z-index for FABs (higher than messages)
                  pointerEvents: "auto",
                }}
              >
                <MobileFAB
                  color="primary"
                  size="small"
                  aria-label={t(
                    "MessagesBody.dateTimePicker",
                    "Date & Time Picker",
                  )}
                  onClick={() => setDateTimeSheetOpen(true)}
                  position="bottom-right"
                  aboveBottomNav={false}
                  sx={{
                    position: "relative",
                    bottom: "auto",
                    right: "auto",
                  }}
                >
                  <AccessTimeRounded />
                </MobileFAB>
              </Box>
            )}
          </Box>

          <Box
            ref={inputAreaRef}
            sx={{
              position: isMobile ? "relative" : "static",
              // Reserve space for input area on mobile
              height: isMobile ? inputAreaHeight || "auto" : "auto",
              minHeight: isMobile ? inputAreaHeight || 0 : 0,
            }}
          >
            <MessageSendArea onSend={onSend} />
          </Box>

          {/* Bottom sheets */}
          {isMobile && (
            <DateTimePickerBottomSheet
              open={dateTimeSheetOpen}
              onClose={() => setDateTimeSheetOpen(false)}
              dateTime={dateTime}
              setDateTime={setDateTime}
            />
          )}
        </Box>
      )}
    </>
  )
}
